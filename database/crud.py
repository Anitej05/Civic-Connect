import os
from datetime import datetime, timezone
from typing import List, Optional

from bson.objectid import ObjectId
from pydantic import BaseModel, Field
from pymongo import MongoClient, GEOSPHERE
from pymongo.collection import Collection
from pymongo.database import Database

# --- Configuration ---
# It's recommended to use environment variables for sensitive data like the DB connection string.
MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017/")
DB_NAME = "civic_connect"

# --- Database Connection ---
client = MongoClient(MONGO_URI)
db: Database = client[DB_NAME]

# Get collections
users_collection: Collection = db.users
reports_collection: Collection = db.reports

# --- Pydantic Data Models ---
# These models define the structure of the documents in your MongoDB collections.

class UserInDB(BaseModel):
    """Model for user documents stored in the database."""
    clerk_user_id: str
    email: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    class Config:
        # Allows the model to be created from BSON/dict objects that include an `_id`
        from_attributes = True
        populate_by_name = True
        json_encoders = {ObjectId: str}

class GeoJSON(BaseModel):
    """Model for GeoJSON Point as used by MongoDB."""
    type: str = "Point"
    coordinates: List[float] # [longitude, latitude]

class ReportInDB(BaseModel):
    """Model for report documents stored in the database."""
    id: Optional[ObjectId] = Field(None, alias="_id")
    user_id: str
    title: str
    description: str
    department: str
    status: str = "submitted"
    location: GeoJSON 
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    class Config:
        from_attributes = True
        populate_by_name = True
        json_encoders = {ObjectId: str}
        arbitrary_types_allowed = True

# --- User CRUD Functions ---

def create_user(clerk_user_id: str, email: str) -> Optional[UserInDB]:
   
   
    if users_collection.find_one({"clerk_user_id": clerk_user_id}):
        return None
    
    user_data = {
        "clerk_user_id": clerk_user_id,
        "email": email,
        "created_at": datetime.now(timezone.utc)
    }
    
    result = users_collection.insert_one(user_data)
    created_user = users_collection.find_one({"_id": result.inserted_id})
    return UserInDB.model_validate(created_user) if created_user else None

def get_user_by_clerk_id(clerk_user_id: str) -> Optional[UserInDB]:
    """Retrieves a single user document from the database by their Clerk ID."""
    user_data = users_collection.find_one({"clerk_user_id": clerk_user_id})
    return UserInDB.model_validate(user_data) if user_data else None


def create_report(report_data: ReportInDB) -> ReportInDB:
    """
    Inserts a new, fully formed report document into the database.
    The `id` field is generated by MongoDB.
    """
    report_dict = report_data.model_dump(by_alias=True, exclude={"id"})
    result = reports_collection.insert_one(report_dict)
    
    
    new_report = reports_collection.find_one({"_id": result.inserted_id})
    return ReportInDB.model_validate(new_report)

def get_reports_by_user_id(user_id: str) -> List[ReportInDB]:
    """Fetches all reports submitted by a specific user, sorted by most recent first."""
    cursor = reports_collection.find({"user_id": user_id}).sort("created_at", -1)
    return [ReportInDB.model_validate(doc) for doc in cursor]

def get_reports_nearby(longitude: float, latitude: float, max_distance_meters: int = 5000) -> List[ReportInDB]:
    """
    Performs a geospatial query to find reports within a radius.
    Requires a '2dsphere' index on the 'location' field in MongoDB.
    """
    query = {
        "location": {
            "$near": {
                "$geometry": {
                    "type": "Point",
                    "coordinates": [longitude, latitude]
                },
                "$maxDistance": max_distance_meters
            }
        }
    }
    cursor = reports_collection.find(query).sort("created_at", -1)
    return [ReportInDB.model_validate(doc) for doc in cursor]

def get_reports_for_admin(department: Optional[str] = None) -> List[ReportInDB]:
    """Fetches all reports, with an optional filter for a specific department."""
    query = {}
    if department:
        query["department"] = department
        
    cursor = reports_collection.find(query).sort("created_at", -1)
    return [ReportInDB.model_validate(doc) for doc in cursor]

def update_report_status(report_id: str, new_status: str) -> Optional[ReportInDB]:
    """Updates the status and updated_at fields of a specific report."""
    try:
        obj_id = ObjectId(report_id)
    except Exception:
      
        return None

    update_result = reports_collection.find_one_and_update(
        {"_id": obj_id},
        {"$set": {"status": new_status, "updated_at": datetime.now(timezone.utc)}},
        return_document=True 
    )
    
    return ReportInDB.model_validate(update_result) if update_result else None


def ensure_indexes():
    """
    Ensures that the required database indexes are created.
    This is a crucial step for query performance and functionality.
    """
   
    users_collection.create_index("clerk_user_id", unique=True)
  
    reports_collection.create_index([("location", GEOSPHERE)])
    print("Database indexes ensured.")

if __name__ == '__main__':
   
    ensure_indexes()
    
    print("Civic Connect DB Layer script loaded successfully.")
